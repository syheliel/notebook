# ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•
A context-free grammar is a quadruple G = (V ğ‘‡, ğ‘ƒ, ğ‘† )
V is a finite set of variables.
T is a finite set of terminals.
P is a finite set of productions of the form ğ´â†’ğ›¼ where ğ´âˆˆğ‘‰, ğ›¼âˆˆ$(ğ‘‰âˆªğ‘‡)^âˆ—$
S is a designated variable called the start symbol

## Derivation(æ¨å¯¼)
- Leftmost derivation $â‡’_{ğ‘™ğ‘š} $
Always replace the leftmost variable by one of its rule-bodies.
- Rightmost derivation $â‡’_{ğ‘Ÿğ‘š} $
Always replace the rightmost variable by one of its rule-bodies.

## parse tree(ç”Ÿæˆæ ‘)

## Ambiguous Grammar(äºŒä¹‰æ€§æ–‡æ³•)
There can be several different derivations for a string
There can be several parse trees for the same derivation of a string
There is only one parse tree for a derivation of string ğ‘¤âˆˆğ¿ if ğ¿ is unambiguous

## Ambiguity(äºŒä¹‰æ€§)
Good news: sometimes we can remove ambiguity from CFG
Bad news: there is no algorithm to do it
Bad news: There are CFLs that has only ambiguous grammars and it is impossible to remove the ambiguity
Good news: there are well-known techniques for eliminating ambiguity in common programming languages

## Leftmost derivation and ambiguity
For any CFG ğº, a string w has two distinct parse trees iff w has two distinct leftmost derivation

## Inherent Ambiguity
A CFL ğ¿ is inherent ambiguous if all grammars for ğ¿ are ambiguous

# ä¸‹æ¨è‡ªåŠ¨æœºï¼ˆPushdown Automataï¼‰
A pushdown automata (PDA) is essentially an ğœ–-NFA with a stack
A PDA is a 7-tuple ğ‘ƒ=(ğ‘„,Î£,Î“,ğ›¿,ğ‘_0,ğ‘_0,ğ¹)
ğ‘„ is a finite set of states
Î£ is a finite set of input symbols
Î“ is a finite set of stack symbols
ğ›¿:$ğ‘„Ã—Î£^{ \epsilon}Ã—Î“â†’2^{(ğ‘„Ã—Î“^âˆ— )}$ is a transition function
ğ‘_0âˆˆğ‘„ is the start state
ğ‘_0âˆˆÎ“ is  the start symbol of the stack
ğ¹âŠ†ğ‘„ is a set of final (accepting) states
## ä¾‹å­
Consider ğ¿_ğ‘¤ğ‘¤ğ‘Ÿ={$ğ‘¤ğ‘¤^ğ‘…$  â”¤|  ğ‘¤âˆˆ{0,1}^âˆ—} with grammar ğ‘†â†’ğœ– | 0ğ‘†0 |1ğ‘†1

![](Screenshots/../Screenshots/2020-08-28-21-33-09.png)

![](Screenshots/../Screenshots/2020-08-28-21-33-38.png)

## ç¬æ—¶æè¿° (Instantaneous Description)
A ID of a PDA is a triple (ğ‘,ğ‘¤,ğ›¼)
ğ‘ is the current state
ğ‘¤ is the remaining input string
ğ›¼ is the current stack contents
Transitions of ID
âˆ€ğ‘¤âˆˆÎ£^âˆ—,ğ›½âˆˆÎ“^âˆ—
(ğ‘,ğ‘ğ‘¤,ğ‘§ğ›½)âŠ¢(ğ‘,ğ‘¤,ğ›¾ğ›½)  if  (ğ‘,ğ›¾)âˆˆğ›¿(ğ‘,ğ‘,ğ‘§)
define âŠ¢^âˆ— to be the reflective-transitive closure of âŠ¢
basis: ğ¼âŠ¢^âˆ— ğ¼ for any ID ğ¼
inductive: ğ¼âŠ¢^âˆ— ğ½ if there is a ğ¾ such that ğ¼âŠ¢ğ¾, ğ¾âŠ¢^âˆ— ğ½ 
![](Screenshots/../Screenshots/2020-08-28-21-34-46.png)

## ä¸‹æ¨è‡ªåŠ¨æœºæ¥å—çš„è¯­è¨€(æŒ‰æœ€ç»ˆçŠ¶æ€æ¥æ”¶/æŒ‰ç©ºæ ˆæ¥æ”¶)
1. Acceptance by the final state
ğ¿(ğ‘ƒ)={ğ‘¤ â”¤|  (ğ‘_0,ğ‘¤,ğ‘_0 ) âŠ¢^âˆ— (ğ‘,ğœ–,ğ›¼)âˆ§ğ‘âˆˆğ¹}

2. Acceptance by the Empty Stack
ğ‘(ğ‘ƒ)={ğ‘¤ â”¤|  (ğ‘_0,ğ‘¤,ğ‘_0 ) âŠ¢^âˆ— (ğ‘,ğœ–,ğœ–)}

## ä¸¤ç§æ¥æ”¶çŠ¶æ€çš„è½¬æ¢
1. From ğ‘(ğ‘ƒ_ğ‘) to ğ¿(ğ‘ƒ_ğ¹)(ç©ºæ ˆ->çŠ¶æ€æ¥æ”¶)
![](Screenshots/../Screenshots/2020-08-28-21-40-56.png)
2. From ğ¿(ğ‘ƒ_ğ¹) to ğ‘(ğ‘ƒ_ğ‘)
![](Screenshots/../Screenshots/2020-08-28-21-41-04.png)

# CFGå’ŒPDAçš„ç­‰ä»·æ€§
L is a language generated by a CFG iff it is accepted by a PDA
a PDA accepts by empty stack
a PDA accepts by final state

## From CFG to PDA
Define ğ‘ƒ_ğº=({ğ‘},ğ‘‡,ğ‘‰âˆªğ‘‡,ğ›¿,ğ‘,ğ‘†)
1. For any ğ´âˆˆğ‘‰, ğ›¿(ğ‘,ğœ–,ğ´)={(ğ‘,ğ›½)|  ğ´â†’ğ›½âˆˆğ‘…}
ç›¸å½“äºåœ¨æ ˆä¸­é‡å¤äº†CFGçš„ç”Ÿæˆè¿‡ç¨‹
2. For any ğ‘âˆˆğ‘‡, ğ›¿(ğ‘,ğ‘,ğ‘)={(ğ‘,ğœ–)}
æ¶ˆæ¶ˆä¹

## From PDA to CFG
![](Screenshots/../Screenshots/2020-08-30-11-36-18.png)
### example
![](Screenshots/../Screenshots/2020-08-30-11-36-45.png)

# ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•çš„èŒƒå¼
## Chomsky Normal Form (CNF)
Every production is of the form ğ´â†’ğµğ¶ or ğ´â†’ğ‘
ğ´,ğµ,ğ¶âˆˆğ‘‰ and ğ‘âˆˆğ‘‡
## Greibach Normal Form (GNF)
Every production is of the form ğ´â†’ğ‘ğ›¼
ğ´âˆˆğ‘‰, ğ‘âˆˆğ‘‡ and ğ›¼âˆˆ$ğ‘‰^âˆ—$
## CFGçš„åŒ–ç®€
### ä¸‰ä¸ªå­ç®—æ³•
1. Eliminate useless symbols(generating and reachable)
A symbol ğ‘‹ is useful if there is a derivation($ğ‘¤âˆˆğ‘‡^âˆ—,ğ‘‹âˆˆğ‘‰âˆªğ‘‡$)
$$S \Rightarrow^* aXb \Rightarrow^* w$$
- Generating: ğ‘‹â‡’^âˆ— ğ‘¤ for some ğ‘¤âˆˆğ‘‡^âˆ—
å³Xæœ€åèƒ½å…¨éƒ¨è½¬åŒ–ä¸ºéç»ˆæ­¢å­—ç¬¦
ç®—æ³•ï¼š
![](Screenshots/../Screenshots/2020-08-30-14-34-29.png)
- Reachable: $ğ‘†\Rightarrow^âˆ—$ ğ›¼ğ‘‹ğ›½ for some {ğ›¼,ğ›½}âŠ†(ğ‘‰âˆªğ‘‡)^âˆ—
åˆå§‹çŠ¶æ€èƒ½å¤Ÿåˆ°è¾¾X
![](Screenshots/../Screenshots/2020-08-30-14-34-55.png)
**æ›¿æ¢**
ç›´æ¥æŠŠåŒ…å«è¿™äº›ç¬¦å·çš„å¼å­å»æ‰
1. Eliminate ğœ–-productions
**ç®—æ³•**
![](Screenshots/../Screenshots/2020-08-30-14-36-40.png)
**æ›¿æ¢**
æŠŠå³ä¾§ä¸ºç©ºçš„è¡¨è¾¾å¼å»æ‰ï¼Œå†æšä¸¾å¯èƒ½ä¸ºç©ºçš„å˜é‡ï¼Œå¦‚Aä¸ºç©ºï¼ŒS->aAAå¯ä»¥å˜ä¸ºS->aAA|aA|a
**Theorem**
If ğº is CFG and ğº_1 is obtained by eliminating ğœ–-productions in ğº, then $ğ¿(ğº_1 )$=ğ¿(ğº)\\ {ğœ–}

3. Eliminate unit productions
that ğ´â†’ğµ

![](Screenshots/../Screenshots/2020-09-01-22-23-37.png)
### é¡ºåº
A safe order for simplifying a CFG
Eliminating ğœ–-productions
Eliminating unit productions
Eliminating useless symbols
**Theorem** 
If ğº is a CFG that ğ¿(ğº)â‰ âˆ…, then there is another CFG ğºâ€² that has no ğœ–-productions, unit productions and useless symbols such thatğ¿(ğº^â€² )=ğ¿(ğº)\\ {ğœ–}

## CFG TO CNF
1. CFGåŒ–ç®€
2. æ›¿æ¢ç»ˆæ­¢ç¬¦
![](Screenshots/../Screenshots/2020-08-30-15-13-11.png)
3. æ›¿æ¢é•¿åº¦å¤§äº2çš„äº§ç”Ÿå¼ 
![](Screenshots/../Screenshots/2020-08-30-15-13-26.png)
### ä¼˜ç‚¹
1. Remove redundancy from grammar
2. Determine the equivalence of two CFLs by comparing the rules of their grammars
3. Make the parse tree of a string w to be a binary tree 
so that the depth of the parse tree satisfies |ğ‘¤|â‰¤2^(ğ‘›âˆ’1)

## Pumping lemma for CFL(æ³µå¼•ç†)
Let ğ¿ be a CFL. Then there exists a constant ğ‘› such that if ğ‘§ is any string in ğ¿ with |ğ‘§|>ğ‘›, then we can write ğ‘§=ğ‘¢ğ‘£ğ‘¤ğ‘¥ğ‘¦ where
- |ğ‘£ğ‘¤ğ‘¥|â‰¤ğ‘›
- |ğ‘£ğ‘¥|>0
- For all ğ‘–â‰¥0, ğ‘¢ğ‘£^ğ‘– ğ‘¤ğ‘¥^ğ‘– ğ‘¦âˆˆğ¿
Two substrings ğ‘£ and ğ‘¥ can be pumped

# ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€çš„åˆ¤å®šæ€§é—®é¢˜
## ğ‘¤âˆˆğ¿
![](Screenshots/../Screenshots/2020-08-30-15-32-02.png)
### example
![](Screenshots/../Screenshots/2020-08-30-15-34-51.png)

## Undecidable Problems about CFLs
- Is a given CFG G ambiguous?
- Is a given CFL inherently ambiguous?
- Is the intersection of two CFLs empty?
- Are two CFLs the same?
- Is a given CFL equal to Î£^âˆ—?